# 函数式编程

是一种编程范式

[函数式编程的历史](https://zhuanlan.zhihu.com/p/24648375?refer=marisa)

纯函数指的是数学意义上的映射关系

纯函数好处

- 可测试
  - 纯函数让测试更方便
- 并行处理
  - 在多线程环境下并行操作共享的内存数据很可能会出现意外情
  - 纯函数不需要访问共享的内存数据，所以在并行环境下可以任意运行纯函数 (Web Worker)

## 柯里化 (Currying)

- 当一个函数有多个参数的时候先传递一部分参数调用它（这部分参数以后永远不变）
- 然后返回一个新的函数接收剩余的参数，返回结果

```js
// 柯里函数
function curry (func) {
  return curriedFn = (...args) => {
    // 判断实参和形参的个数
    return args.length < func.length 
    ? (...moreArgs) => curriedFn(...args.concat(moreArgs))
    : func(...args)
  }
}
```

## 函数组合（compose）

```js
const compose = (...args) => value => args.reverse().reduce((acc, fn) => fn(acc), value)
```

函数组合要满足结合律 (associativity)：

```js
// 结合律（associativity）
let f = compose(f, g, h)
let associative = compose(compose(f, g), h) == compose(f, compose(g, h)) // true
```



## Point Free

把数据处理的过程定义成与数据无关的合成运算，不需要用到代表数据的那个参数，只要把简单的运算步骤合成到一起，在使用这种模式之前我们需要定义一些辅助的基本运算函数。 

- 不需要指明处理的数据
- 只需要合成运算过程
- 需要定义一些辅助的基本运算函数

简单的说就是 compose

## Functor (函子)

- 函数式编程的运算不直接操作值，而是由函子完成 函子就是一个实现了 map 契约的对象
- 我们可以把函子想象成一个盒子，这个盒子里封装了一个值
- 想要处理盒子中的值，我们需要给盒子的 map 方法传递一个处理值的函数（纯函数），由这个函数来对值进行处理 
- 最终 map 方法返回一个包含新值的盒子（函子）

静态 `of` 方法来返回一个新的自己，以便链式调用

`map` 方法接受一个纯函数，对自己的值进行操作

### MayBe函子

作用就是处理外部的空值

在执行 `map` 时会对函子的值进行检查，如果是控制就不执行传入 `map` 的函数

### Either函子

就是组合两个函子，一个就是正常的函子，另一个函子是 `map` 方法只会返回自己

这样在写一个函数的时候，用 `try catch` 去写，正常就执行前者，出错了就执行后一个函子

### IO函子

带副作用的操作终究是不能避免的，但是我们可以延迟这个不纯的操作

从这个函子开始就把函子的 `value` 当成了一个函数

这样每次在 `map` 的时候，都会进行 compose

```js
map(fn) {
	return new IO(compose(fn, this._value))
}
```

最后在调用的时候才有副作用

### folktble

一个标准的函数式编程库，没有多的功能函数

### Task函子

是 folktale 中的一个函子，接受像 Promise 构造器参数一样的函数

`map` 接受纯函数，`run` 执行，`listen` 方法接受一个对象，上面有 `onRejected` 和 `onResolved` 两个属性，都是（事件）函数，以这种事件监听的方式去查看结果

### Pointed函子

实现了 of 静态方法的函子

of 方法是为了避免使用 new 来创建对象，更深层的含义是 of 方法用来把值放到上下文 Context（把值放到容器中，使用 map 来处理值）

前面都有用到这个概念

### Monad 单子

IO 函子嵌套不好用，所以有了 Monad

有 join 和静态 of 两个方法

`join` 直接返回函子中值的调用（函数调用）

`flatMap` 就是先 map 后得到有最新的一大堆操作的函数的函子，再调用 join 去执行（等于解开一个函子的嵌套，并马上执行了函数），得到的值又给传到了后面，如果后面的函数又返回了一个函子，这样就是有一个带闭包的函数函子（）

简单说就是函数直接返回值或者函数的就用 map，直接返回函子的用 flatMap



# 异步编程

一般以回调的形式去写异步之后的处理过程

我们说的同步异步不是指我们写代码的方式，而是运行环境提供的 API 是以同步或异步模式的方式工作

## 回调

所有异步编程方案的原本模样

## Promise

只有三种状态 pending，fulfilled，rejected

- Promise 对象的 then 方法返回一个全新的 Promise 对象
- 后面的 then 方法就是在为上一个 then 返回的 Promise 注册回调
- 前面 then 方法中回调函数的返回值会作为后面 then 方法回调的参数
- 如果回调中返回的是 Promise，那后面的 then 方法的回调会等待它结束

then 里面只接收两个函数作为参数，别的执行语句是不是对 then 链有什么影响的，除非执行语句是个高阶函数的调用又返回了一个函数（即 then 只接收函数，不是函数的语句本身没错的话当然也不会报错，不过是如果语句本身有 ReferenceError 或者 SyntaxError 等错误那后面写 catch 也没用）

catch 异常处理，catch 相当于 `then(undefined, () => {})` 

在 Promise 链上如果异常了就会一直往后传递这个异常

浏览器注册 unhandledrejection 处理异常

node 注册 unhandleRejection 处理异常

在代码中应该明确捕获每一个可能的异常，尽量不要丢给全局

静态方法

- `Promise.resolve()` 快速返回一个 fulfilled 的 promise
  - 可以直接接受要返回的值
  - 可以接受一个对象，上面有 then 属性，值就是 then 函数的回调参数，这种对象就叫实现了 thenable 接口的对象

**在执行下一次宏任务时，要先执行完所有的微任务**

在浏览器，Promise 和 MutationObserver，在 node 中，process.nextTick 这些都是微任务

## generator

需要执行器，在 async / await 之前很流行

generator 函数有个 `*`  号在 `function` 后面，yield 会阻塞代码的执行

generator 函数执行后，会得到一个对象，有 value 和 done 属性，value 是 yield 后面的语句返回的内容，done 指生成器是否完成

```js
function co (generator) {
	const g = generator()
  
  function handleResult (result) {
    if (result.done) return
    result.value.then(data => {
      handleResult(g.next(data)) // 将上一次执行的结果丢给 yield 前的赋值语句，并递归执行这个 generator
    }, error => {
      g.throw(error)
    })
  }
  
  handleResult(g.next())
}
```

[co 源码](https://github.com/tj/co)

## Async / await 

语言层面的对 generator 封装的语法糖，generator 函数的星号去掉，在 function 关键字前加个 async，yield 换成 await，不需要执行器，很好使


# 手写 Promise

1. Promise 是一个类，构造参数是一个执行器函数，会立即执行
2. Promise 有三种状态，分别是成功 fulfilled，失败 rejected，等待 pending，状态一旦确定就不可更改
3. 执行器函数参数 resolve 和 reject，是两个函数，resolve 让状态变成 fulfilled，reject 让状态变成 rejected
4. then 方法内部就是判断状态是什么，成功就调用成功回调，失败就调用失败回调，then 被定义在原型对象中
5. then 里面两个回调函数都有参数，成功就是成功返回的结果，是失败返回的原因
6. 执行器里如果写的代码是异步代码，then 里面写的回调就先保存起来，然后等 resolve 或者是 reject 的时候再调用回调。
7. 一个 promise 是可以被多次 then 的，这样的话，回调就要用数组去存储
8. then 是可以被链式调用的，then 方法会返回一个新的 promise
   - then 的回调返回值需要判断是普通值还是 promise 对象
   - 如果是普通值，直接 resolve
   - 如果是 promise 要返回 promise 对象返回的值
   - 在根据 promise 对象返回的结果决定 resolve 还是 reject（用then方法）

9. then 里不允许返回自己，这会造成循环调用的错误
10. Promise 里的构造函数和 then 里面都要捕获错误，如果有错误就 reject
11. then 方法的参数都是可选参数
12. 静态 all 方法
13. 静态 resolve 方法
14. finally 方法，无论 promise 的状态是成功还是失败都要调用这里面的回调方法
    - finally 返回一个新 promise，也可以用 then 继续链式调用
    - finally 里的回调如果是异步的要先执行了异步再执行后面的 then
    - 用 `Promise.resolve` 和 `then` 就能实现

15. catch 方法，用 `then` 可以不传递第一个回调即成功回调，只传失败的回调来实现


